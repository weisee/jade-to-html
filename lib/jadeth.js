// Generated by CoffeeScript 1.7.1
(function() {
  var allowedFilenames, compileJadeFile, data, destinationDir, fs, handleWatch, jade, renderFile, renderFileSync, renderOrWalk, renderOrWalkSync, resolveCompiledPath, resultExtenstion, walkAndRender, walkAndRenderSync, watchDir;

  fs = require('fs');

  jade = require('jade');

  allowedFilenames = new RegExp('^.*\.jade$');

  watchDir = '/';

  destinationDir = '/';

  data = {};

  resultExtenstion = 'html';

  module.exports = function(currentDir, target, destDir, dataFile, resExt, watch) {
    data = require(currentDir + '/' + dataFile);
    watchDir = currentDir + '/' + target;
    destinationDir = destDir ? currentDir + '/' + destDir : watchDir;
    resultExtenstion = '.' + (resExt ? resExt : resultExtenstion);
    console.log('Render to ', destinationDir);
    console.log('With extension ', resultExtenstion);
    if (watch) {
      console.log('ASYNC MODE. Watch enabled.');
      walkAndRender(watchDir);
      return fs.watch(watchDir, handleWatch);
    } else {
      console.log('SYNC MODE.');
      return walkAndRenderSync(watchDir);
    }
  };

  walkAndRender = function(dir) {
    return fs.readdir(dir, function(err, list) {
      var file, filename, listLength, _i, _len, _results;
      if (err) {
        throw new Error(err);
      }
      listLength = list.length;
      if (!listLength) {
        return null;
      }
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        file = list[_i];
        filename = dir + '/' + file;
        _results.push(renderOrWalk(filename));
      }
      return _results;
    });
  };

  walkAndRenderSync = function(dir) {
    var file, filename, list, listLength, _i, _len, _results;
    list = fs.readdirSync(dir);
    if (list instanceof Error) {
      throw list;
    }
    listLength = list.length;
    if (!listLength) {
      return null;
    }
    _results = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      file = list[_i];
      filename = dir + '/' + file;
      _results.push(renderOrWalkSync(filename));
    }
    return _results;
  };

  renderOrWalk = function(filename) {
    return fs.stat(filename, function(err, stat) {
      if (err) {
        throw new Error(err);
      }
      if (stat && stat.isDirectory()) {
        return walkAndRender(filename);
      } else {
        return renderFile(filename);
      }
    });
  };

  renderOrWalkSync = function(filename) {
    var stat;
    stat = fs.statSync(filename);
    if (stat instanceof Error) {
      throw stat;
    }
    if (stat && stat.isDirectory()) {
      return walkAndRenderSync(filename);
    } else {
      return renderFileSync(filename);
    }
  };

  handleWatch = function(event, filename) {
    if (!allowedFilenames.test(filename)) {
      return false;
    }
    return renderFile(watchDir + '/' + filename);
  };

  resolveCompiledPath = function(filename, domain) {
    var fileDir;
    filename = filename.replace(/\.jade$/, resultExtenstion);
    filename = filename.replace(watchDir, '');
    filename = filename.replace(/^\/*/, '');
    filename = filename.split('/').join('-');
    if (domain) {
      fileDir = [destinationDir, domain].join('/');
      if (!fs.existsSync(fileDir)) {
        fs.mkdirSync(fileDir);
      }
      filename = [fileDir, filename].join('/');
    } else {
      filename = [destinationDir, filename].join('/');
    }
    return filename;
  };

  renderFile = function(filename) {
    var domain, _ref, _results;
    _ref = data.domains;
    _results = [];
    for (domain in _ref) {
      data = _ref[domain];
      _results.push(compileJadeFile(filename, domain, data));
    }
    return _results;
  };

  renderFileSync = function(filename) {
    var compiledPath, domain, domainData, err, fn, html, template, _ref, _results;
    template = fs.readFileSync(filename, {
      encoding: 'utf8'
    });
    if (template instanceof Error) {
      throw template;
    }
    fn = jade.compile(template);
    if (fn instanceof Error) {
      throw fn;
    }
    _ref = data.domains;
    _results = [];
    for (domain in _ref) {
      domainData = _ref[domain];
      compiledPath = resolveCompiledPath(filename, domain);
      html = fn(domainData);
      if (html instanceof Error) {
        throw html;
      }
      err = fs.writeFileSync(compiledPath, html);
      console.log(compiledPath, ' compiled.');
      if (err) {
        throw err;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  compileJadeFile = function(filename, domain, data) {
    data = data || {};
    return jade.renderFile(filename, data, function(err, html) {
      var compiledPath;
      if (err) {
        return console.error(err);
      }
      compiledPath = resolveCompiledPath(filename, domain);
      return fs.writeFile(compiledPath, html, function(err) {
        if (err) {
          return console.error(err);
        }
        return console.log(compiledPath, ' compiled.');
      });
    });
  };

}).call(this);
